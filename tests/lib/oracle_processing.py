from logging import getLogger
from typing import List, Optional
import os

import pandas as pd
from pandas.io import sql as psql
from pandas.util.testing import assert_frame_equal
import cx_Oracle

from tests.lib.base_processing import BaseProcessing

logger = getLogger(__name__)


class OracleProcessing(BaseProcessing):

    _column_types_and_names_matching = {
        "id_int": "INTEGER GENERATED BY DEFAULT AS IDENTITY",
        "text_string": "VARCHAR2(50) NOT NULL",
        "hwm_int": "INTEGER",
        "hwm_date": "DATE",
        "hwm_datetime": "TIMESTAMP",
    }

    def __enter__(self):
        self.connection = self.get_conn()
        return self

    def __exit__(self, _exc_type, _exc_value, _traceback):
        self.connection.close()
        return False

    @property
    def sid(self) -> str:
        return os.getenv("ONETL_ORA_CONN_SID")

    @property
    def user(self) -> str:
        return os.getenv("ONETL_ORA_CONN_USER")

    @property
    def password(self) -> str:
        return os.getenv("ONETL_ORA_CONN_PASSWORD")

    @property
    def host(self) -> str:
        return os.getenv("ONETL_ORA_CONN_HOST")

    @property
    def database(self) -> str:
        return os.getenv("ONETL_ORA_CONN_DATABASE")

    @property
    def url(self) -> str:
        sid = cx_Oracle.makedsn(self.host, 1521, sid=self.sid)
        return f"oracle://{self.user}:{self.password}@{sid}"

    @property
    def port(self) -> int:
        return int(os.getenv("ONETL_ORA_CONN_PORT"))

    def create_schema(
        self,
        schema: str,
    ) -> None:
        """"""

    def create_table(
        self,
        table: str,
        fields: List,
        schema: str,
    ) -> None:
        with self.connection.cursor() as cursor:
            str_fields = ", ".join([f"{f['column_name']} {f['type']}" for f in fields])
            sql = f"CREATE TABLE {schema}.{table} ({str_fields})"
            cursor.execute(sql)
            self.connection.commit()

    def drop_database(
        self,
        schema: str,
    ) -> None:
        with self.connection.cursor() as cursor:
            cursor.execute(f"DROP DATABASE {schema}")
            self.connection.commit()

    def drop_table(
        self,
        table: str,
        schema: str,
    ) -> None:
        with self.connection.cursor() as cursor:
            cursor.execute(f"DROP TABLE {schema}.{table}")
            self.connection.commit()

    def get_conn(self) -> cx_Oracle.Connection:
        try:
            cx_Oracle.init_oracle_client(lib_dir=os.getenv("ONETL_ORA_CLIENT_PATH"))
        except Exception:
            logger.debug("cx_Oracle client is already initialized.", exc_info=True)
        dsn = cx_Oracle.makedsn(self.host, self.port, sid=self.sid)

        return cx_Oracle.connect(user=self.user, password=self.password, dsn=dsn)

    def insert_data(
        self,
        schema: str,
        table: str,
        values: "pandas.core.frame.DataFrame",
    ) -> None:

        # <con> parameter is SQLAlchemy connectable or str
        # A database URI could be provided as as str.
        psql.to_sql(
            frame=values,
            name=table,
            con=self.url,
            index=False,
            schema=schema,
            if_exists="append",
        )

    def get_expected_dataframe(
        self,
        schema: str,
        table: str,
    ) -> "pandas.core.frame.DataFrame":

        return pd.read_sql_query(f"SELECT * FROM {schema}.{table}", con=self.connection)

    def stop_conn(self) -> None:
        self.connection.close()

    def assert_equal_df(
        self,
        schema: str,
        table: str,
        df: "pyspark.sql.DataFrame",
        other_frame: Optional["pandas.core.frame.DataFrame"] = None,
    ) -> None:

        if not other_frame:
            other_frame = self.get_expected_dataframe(schema=schema, table=table)

        # Type conversion is required since spark cannot read the int data type from oracle
        convert_rules = {}

        df = df.toPandas()

        for column in df:

            column_name_words = [column_word.lower() for column_word in column.split("_")]

            if "int" in column_name_words:
                convert_rules[column] = "int64"
            if "datetime" in column_name_words or "date" in column_name_words:
                convert_rules[column] = "datetime64[ns]"

        df = df.astype(convert_rules)

        # converting to lowercase for comparing data frames column names
        rename_columns = {x: x.lower() for x in df}
        df = df.rename(columns=rename_columns, inplace=False)
        rename_columns.clear()

        rename_columns = {x: x.lower() for x in other_frame}
        other_frame = other_frame.rename(columns=rename_columns, inplace=False)

        assert_frame_equal(
            left=df,
            right=other_frame,
            check_dtype=False,
        )
